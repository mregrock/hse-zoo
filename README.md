# HSE Zoo Management System

Система управления зоопарком, реализованная с использованием Spring и принципов SOLID.

## Содержание
1. [Требования](#требования)
2. [Установка и запуск](#установка-и-запуск)
3. [Архитектура](#архитектура)
4. [Принципы SOLID](#принципы-solid)
5. [Паттерны проектирования](#паттерны-проектирования)
6. [Тестирование](#тестирование)

## Требования
- Java 17 или выше
- Maven 3.6 или выше
- Spring Boot 2.7.5

## Установка и запуск
1. Клонируйте репозиторий:
   ```bash
   git clone https://github.com/mregrock/hse-zoo.git
   ```
2. Сборка и запуск:
   ```bash
   mvn clean install
   java -jar target/hse-zoo-0.0.1-SNAPSHOT.jar
   ```

## Архитектура
Проект частично построен по принципу MVC, где место Contoroller занимает ZooService, а место View занимает ConsoleView.

## Принципы SOLID

### 1. Single Responsibility Principle (SRP)
Каждый класс имеет только одну причину для изменения:

- `Zoo` - управляет только коллекцией животных
- `VeterinaryClinicService` - отвечает только за проверку здоровья
- `ZooService` - отвечает за управление зоопарком
- `ConsoleView` - отвечает за взаимодействие с пользователем

### 2. Open/Closed Principle (OCP)
Классы должны быть открыты для расширения, но закрыты для модификации:

- Абстрактный класс `Animal` позволяет добавлять новые виды животных
- Система фабрик позволяет добавлять новые типы животных без изменения существующего кода
- Иерархия параметров `AnimalData`, `HerbivorousData`, `PredatorData`, `OmnivorousData` позволяет легко добавлять новые параметры для животных и очень удобно с ними взаимодействовать. Это видно при создании фабрик - такая сложная иерархия себя оправдала.

### 3. Liskov Substitution Principle (LSP)
Подтипы могут заменять базовые типы:

- Все животные (`HerbivorousAnimal`, `PredatorAnimal`, `OmnivorousAnimal`) корректно реализуют `Animal`
- Все данные о животных (`HerbivorousData`, `PredatorData`, `OmnivorousData`) корректно реализуют `AnimalData`
- Каждый тип животного может использоваться там, где ожидается базовый класс `Animal`

### 4. Interface Segregation Principle (ISP)
Интерфейсы разделены на специфические части:

- `Alive` - базовый интерфейс для живых существ
- `Inventory` - интерфейс для всех подлежащих инвентаризации сущностей
- `Herbivorous` - интерфейс поведения для травоядных
- `Predator` - интерфейс поведения для хищников
- `Omnivorous` - интерфейс поведения для всеядных, объединяющий возможности травоядных и хищников

### 5. Dependency Inversion Principle (DIP)
Высокоуровневые модули не должны зависеть от низкоуровневых:

- `ZooService` не зависит от конкретных классов, а только от абстракций
- `ConsoleView` не зависит от конкретных классов, а только от абстракций
- Использование Spring DI для внедрения зависимостей

## Паттерны проектирования

### 1. Factory Method

Для создания животных используется фабричный метод. В зависимости от поданных на вход параметров, вызывается соответствующая фабрика, создающая соответствующее животное.

### 2. Dependency Injection

С использованием Spring DI внедряются зависимости в классы.

Задача весьма камерная, потому применять множество паттернов нецелесообразно. Тем более часть паттернов уже реализована в Spring, например Singleton.


## Тестирование

Тестирование проводилось с использованием JUnit и Mockito. Покрытие тестов проверялось с помощью Coverage - больше 60%.
